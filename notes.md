# TETRIS wit gyroscope controls

## General Architecture
The system operates via a while-loop, after a short initialization process. Depending on the global state (explained below), the system calls different functions to perform different actions.

## Global State
The global state controls what the system should be doing at any given moment. There are three different states defined:
- `wait_to_start`	: In this state, the game is in an idle loop awaiting for user interaction. Once interacted with, a game will start
- `playing`			: A game is being played; This state will be over once the player loses
- `game_over`		: Entered after the player loses; The final score of the player is displayed for some time. After that goes back to `wait_to_start`

In addition to the state the game is in, the global state stores the current score of the game. In `wait_to_start`, the score is set to 0. 
While in the `playing` state, the score will increase. Once `game_over` is entered the game only needs to display the score value.

## Game Loop
The game loop is performed when the system is in the `playing` state. A number of functions have to be performed during this loop.
After all functions that should be performed have been executed, the system enters a small wait interval.

### Game State
The game state encodes what is happening in the game and is only active during `playing`. The state itself is a python object with the following fields:
- `current_block`	: 
	An object encoding the block that is currently falling. Generated by `generate_block()` during the start of the game or after it its cleared by `check_pile()`. 
	The position of the block and its shape are encoded here
- `wait_interval`	: 
	Scalar value. The number of milliseconds the game waits before re-executing the game loop. 
	Decreases slightly as the score increases to make the game harder.
- `pile_obj`		: 
	The state of the pile. Just an 8x8 array of either 0s or 1s.

### Game Loop Functions
`generate_block()`	: a new, random block is generated at a random region of the screen. This function is executed only after `current_block` has been cleared.
`poll_input`		: the accelerometer is polled and a new input is read. The currently falling block is updated accordingly.
`drop_block()`		: the currently falling block drops by a single pixel. This function also handles the unification of the falling block with the pile. May clear `current_block`
`check_pile()`		: The state of the pile is checked and lines are removed if full. The score is updated.

`wait()		`		: The system enters an idle state for a short amount of time (to let the player process what happened)

## Graphics Engine
The system has a simple 8x8 RGB grid display. Depending on the current global state a different draw function is executed. All functions may use the `frame` variable to control what they should display (useful for animations)
`frame` increases by one in each main-loop.

### Draw in wait_to_start
A simple animation may be shown.

### Draw in playing
This function is split into two parts: `draw_block()` and `draw_pile()`. The first function takes as argument the `current_block` object and displays it on screen. Color is used.
The second function takes as an argument `pile_obj` and places it on the screen. The pile could be displayed in just one colour.

### Draw in game_over
The score of the player scrolls past the screen a few times. The `frame` variable is used to determine which part of the number should be displayed.
